<!DOCTYPE html PUBLIC "-//W3C//DTD Html 1.0 Strict//EN" "http://www.w3.org/TR/Html1/DTD/strict.dtd"><html><head><title>HuddersfieldRCode</title></head><body><p><font face="Arial" color="#000100" size="1"># create.kernel: Generates kernel matrix k_ij for use in WinBUGS pois.conv model<br>#<br># Written by Robert Wolpert; last modified by Nicky Best August 2004.<br>#<br>create.kernel &lt;- function(rho=stop(&quot;Need radius rho in km&quot;), sig=10,<br>nx, ny, Xx, Xy, outfile=&quot;&quot;, band=0, seed= 17,<br>sw, ne) {<br>#<br># rho = radius of Gaussian kernel (ASSUMED TO BE GIVEN IN KILOMETRES)<br># sig = number of significant figures for kernel matrix<br># nx = number of 'columns' of latent grid cells <br># ny = number of 'rows' of latent grid cells<br># Xx, Xy = vectors containing, respectivel, x and y co-ordinates of centroids of each area <br># in the main study region in metres, ASSUMED TO BE MEASURED IN METRES <br># outfile = name of file to write output to<br># band = width (in km) of boundary to include round edge of study region<br># to allow for edge effects<br># seed = random number seed (Use seed=0 for &quot;random&quot; seed)<br># sw = vector of x and y co-ordinates of south-west corner of study region<br># ne = vectore of x and y co-ordinates of north-east corner of study region<br>#<br># Note: latent grid cells will be defined by splitting the horizontal distance<br># between (sw$x - band*rho) and (ne$x + band*rho) into ncol equally-spaced 'columns'<br># and the vertical distance between (sw$y - band*rho) and (ne$y + band*rho) into<br># nrow equally spaced rows.<br>#<br>if(seed&gt;0) set.seed(seed); <br>if(rho &lt;= 0) stop(&quot;Radius must be positive&quot;);<br>if(rho &gt; 50) rho &lt;- rho/1000; # Assume rho must be give in metres, so convert to km<br>#<br># Make (nx*ny) by 2 matrix of latent cells B_{ij}:<br>#<br># Define latent grid space (Sdat) as study region, plus a boundary of width band*rho (in km):<br>#<br>Sdat &lt;- list(sw=sw-rep(band*rho*1000,2),<br>ne=ne+rep(band*rho*1000,2));<br>dxy &lt;- 0.001*(Sdat$ne-Sdat$sw)/c(nx,ny); # Dim (in km) of each latent grid cell B_{ij}<br>NS &lt;- nx*ny; # number of latent grid cells<br>#<br># Read in study region area centroids (in m):<br>#<br>NX &lt;- length(Xx); # number of areas in study region<br>#<br># Make NX x NS kernel matrix of X,S pairs:<br>#<br>Sx &lt;- seq(Sdat$sw[1],,1000*dxy[1],nx+1); # latent grid cell (B_{ij}) boundarys, in metres<br>Sy &lt;- seq(Sdat$sw[2],,1000*dxy[2],ny+1);<br>ker &lt;- matrix(0,nrow=NX,ncol=NS);<br><br># evaluate the kernel (involves Gaussian integral over each latent grid cell)<br>for(i in 1:NX) {<br>Fx &lt;- pnorm(.001*(Sx-Xx[i])/rho); dFx&lt;-Fx[-1]-Fx[-(nx+1)];<br>Fy &lt;- pnorm(.001*(Sy-Xy[i])/rho); dFy&lt;-Fy[-1]-Fy[-(ny+1)];<br>ker[i,] &lt;- rep(dFx,rep(ny,nx)) * rep(dFy,nx);<br>}<br>ker &lt;- 10000 * ker # Improve precision<br>prec &lt;- 10000 * prod(dxy); # Inverse scale factor<br>dimnames(ker) &lt;- NULL; # Remove dim names<br>ker[is.na(ker)] &lt;- 0; # Null any NA's<br>minker &lt;- 10^(-4);<br>ker[ker&lt;minker] &lt;- minker; # Floor to fool WinBUGS (doesn't allow zeros in kernel)<br>#<br># Fill out list for output:<br>#<br> dpg &lt;- list(<br> ker = t(ker), # in ROW-major format for BUGS<br></font><font face="Arial" color="#FF0000" size="1"> # ********** VERY IMPORTANT *********************<br> # REMEMBER TO EDIT .Dim statement in output<br> # file to switch dimensions of ker<br> # before reading into WinBUGS<br> # ***********************************************</font><font face="Arial" color="#000100" size="1"><br> prec = prec, # Inverse scale factor for kernel<br> J = NS, I = NX, # Numbers of areas in study region (I) and <br> # number of latent grid cells (J)<br> area= prod(dxy), # Area in km^2 of each latent grid cell B_j<br> dx = dxy[1], dy = dxy[2], rho = rho); # Dimensions in km of B_j and radius of Gaussian<br> # kernel (not needed by WinBUGS, so delete before<br> # reading output file into WinBUGS, or include as<br> # dummy variables in bugs code)<br><br> if(sig&lt;10) {<br> dpg$ker &lt;- round (dpg$ker, sig);<br> dpg$prec &lt;- round (dpg$prec, sig);<br> dpg$area&lt;- round (dpg$area,sig);<br> dpg$dx &lt;- round (dpg$dx, sig);<br> dpg$dy &lt;- round (dpg$dy, sig);<br> dpg$rho &lt;- round (dpg$rho, sig);<br> }<br> if(outfile!=&quot;&quot;) { dput(dpg,outfile); }<br> invisible(dpg);<br>}<br><br>#####<br>##### example of how to call function to create kernel for air pollution and respiratory illness example in GeoBUGS 1.2 manual:<br>#####<br>##### create.kernel(rho=1, sig=6, nx=12, ny=8, x, y, outfile=&quot;kernel.txt&quot;, <br>##### band=2, seed= 17, sw=c(399000,402000), ne=c(428250,422250))<br>#####<br>##### where x and y are vectores containing the x and y co-ordinates<br>##### of each area centroid in the study region <br>#####<br>##### This function call will create a latent grid with 12 x 8 latent cells, and calculate<br>##### the kernel weights k[i,j] = 1/(2*pi*rho^2) * exp(-|x[i] - s[j]|^2 / 2*rho^2)<br>##### where |x[i] - s[j]| is the euclidean distance between the centroid of area i of the study<br>##### region and latent grid cell j <br></font></p></body></html>