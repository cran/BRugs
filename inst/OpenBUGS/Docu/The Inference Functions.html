<!DOCTYPE html PUBLIC "-//W3C//DTD Html 1.0 Strict//EN" "http://www.w3.org/TR/Html1/DTD/strict.dtd"><html><head><title>The Inference Functions</title></head><body><p><font face="Arial" color="#000100" size="2"><img src="the inference functions0.bmp" alt="[the inference functions0]"></font><font face="Arial" color="#000100" size="6"><strong>&nbsp;&nbsp;&nbsp;The R Inference Functions</strong></font><font face="Arial" color="#000100" size="2"><br></font><font face="Arial" color="#0000FF" size="2"><br></font><font face="Arial" color="#000100" size="2"><a id="Contents"></font><font face="Arial" color="#000100" size="5"><strong>Contents</strong></font><font face="Arial" color="#000100" size="2"></a><br></font><font face="Arial" color="#000100" size="3"><br>&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#0000FF" size="4"><a href="#GeneralProperties"></font><font face="Arial" color="#0000FF" size="4"><u>General&nbsp;properties</u></font><font face="Arial" color="#0000FF" size="4"></a></font><font face="Arial" color="#000100" size="4"><br>&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#0000FF" size="4"><a href="#Samples"></font><font face="Arial" color="#0000FF" size="4"><u>Samples</u></font><font face="Arial" color="#0000FF" size="4"></a></font><font face="Arial" color="#000100" size="4"><br>&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#0000FF" size="4"><a href="#Summary"></font><font face="Arial" color="#0000FF" size="4"><u>Summary</u></font><font face="Arial" color="#0000FF" size="4"></a></font><font face="Arial" color="#000100" size="4"><br>&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#0000FF" size="4"><a href="#Rank"></font><font face="Arial" color="#0000FF" size="4"><u>Rank</u></font><font face="Arial" color="#0000FF" size="4"></a></font><font face="Arial" color="#000100" size="4"><br>&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#0000FF" size="4"><a href="#DIC"></font><font face="Arial" color="#0000FF" size="4"><u>DIC</u></font><font face="Arial" color="#0000FF" size="4"></a></font><font face="Arial" color="#000100" size="2"><br><br><a id="GeneralProperties"></font><font face="Arial" color="#000100" size="5"><strong>General properties</strong></font><font face="Arial" color="#000100" size="2"></a> </font><font face="Arial" color="#0000FF" size="3"><a href="#Contents">[top]</a><br></font><font face="Arial" color="#000100" size="2"><br></font><font face="Arial" color="#000000" size="3">These R functions are for making inferences about parameters of the model or about the fit of the model. The commands are divided into three groups: the first group 'Samples' concern an entire set of monitored values for a variable; the next group 'Summary' and 'Rank' are space-saving short-cuts that monitor running statistics; and the final group, DIC, concerns evaluation of the </font><font face="Arial" color="#000000" size="3"><em>Deviance Information Criterion</em></font><font face="Arial" color="#000000" size="3"> proposed by </font><font face="Arial" color="#0000FF" size="3"><a href="../Docu/References.html#DICPaper"></font><font face="Arial" color="#0000FF" size="3"><u>Spiegelhalter&nbsp;</u></font><font face="Arial" color="#0000FF" size="3"><em><u>et&nbsp;al</u></em></font><font face="Arial" color="#0000FF" size="3"><u>.&nbsp;(2002)</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3">. </font><font face="Arial" color="#000000" size="3"><strong>Users should ensure their simulation has converged before using functions in the Summary, Rank or DIC groups.</strong></font><font face="Arial" color="#000000" size="3"><em> </em></font><font face="Arial" color="#000000" size="3">Note that if the MCMC simulation has an adaptive phase it will not be possible to make inference using values sampled before the end of this phase.</font><font face="Arial" color="#000000" size="2"><br></font><font face="Arial" color="#000100" size="2"><br><a id="Samples"></font><font face="Arial" color="#000100" size="5"><strong>Samples...</strong></font><font face="Arial" color="#000100" size="2"></a> </font><font face="Arial" color="#0000FF" size="3"><a href="#Contents">[top]</a></font><font face="Arial" color="#000100" size="2"><br><br></font><font face="Arial" color="#000100" size="3">This command opens a non-modal dialog for analysing stored samples of variables produced by the MCMC simulation. The fields are:<br><br>The functions </font><font face="Arial" color="#000100" size="3"><em>samples.set, samples.clear, samples.stats, samples.history, samples.autoC, samples.density, samples.bgr, samples.correl</em></font><font face="Arial" color="#000100" size="3"> act on a variable of interest. This variable of interest must be given as the node argument of above samples functions. It can either be the name of a variable in the model or an R object with the same name as a variable in the model. If the variable of interest is an array, slices of the array can be selected using the notation variable[lower0:upper0, lower1:upper1, ...]. </font><font face="Arial" color="#000000" size="3">A star '*' can be entered as shorthand for all the stored samples. The beg and end arguments can be used to select a slice of monitored values corresponding to iterations beg:end. Likewise the firstChain and lastChain arguments can be to select a sub group of chains to calculate statistics for. The thin argument can be used to only use every thin th value of the stored sample for statistics. If these parameters are left at their default values the whole sample for all chains will be used in calculating statistics.<br><br></font><font face="Arial" color="#000000" size="3"><em><a id="DevianceDefinition">WinBUGS</em></font><font face="Arial" color="#000000" size="3"> generally automatically sets up a logical node to measure a quantity known as </font><font face="Arial" color="#000000" size="3"><em>deviance</a></em></font><font face="Arial" color="#000000" size="3">; this may be accessed, in the same way as any other variable of interest, by typing its name, i.e. &quot;deviance&quot;, in the </font><font face="Arial" color="#000000" size="3"><em>node</em></font><font face="Arial" color="#000000" size="3"> field of the </font><font face="Arial" color="#000000" size="3"><em>Sample Monitor Tool</em></font><font face="Arial" color="#000000" size="3">. The definition of deviance is -2 * log(likelihood): 'likelihood' is defined as p( </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> | </font><font face="Arial" color="#000000" size="3"><em>theta</em></font><font face="Arial" color="#000000" size="3"> ), where </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> comprises all stochastic nodes given values (i.e. data), and </font><font face="Arial" color="#000000" size="3"><em>theta</em></font><font face="Arial" color="#000000" size="3"> comprises the </font><font face="Arial" color="#000000" size="3"><em>stochastic parents</em></font><font face="Arial" color="#000000" size="3"> of </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> - 'stochastic parents' are the stochastic nodes upon which the distribution of </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> depends, when collapsing over all logical relationships.<br></font><font face="Arial" color="#000100" size="3"><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.set:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.set(node)</em></font><font face="Arial" color="#000100" size="3"> is used to start recording a chain of values for the variable node.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.clear:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.clear(node)</em></font><font face="Arial" color="#000100" size="3"> is used to removes the stored values of the variable from computer memory.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.history:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.history(</em></font><font face="Arial" color="#000100" size="3">node, beg = samples.get.beg(), end = samples.get.end(),firstChain = samples.get.firstChain(), lastChain = samples.get.lastChain(), <br>thin = samples.get.thin()</font><font face="Arial" color="#000100" size="3"><em>)</em></font><font face="Arial" color="#000100" size="3"> plots out a complete trace for the variable.<br><br>The next four functions can only be executed if the MCMC simulation is not in an adaptive phase.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.density:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.density(</em></font><font face="Arial" color="#000100" size="3">node, beg = samples.get.beg(), end = samples.get.end(), firstChain = samples.get.firstChain(), lastChain = samples.get.lastChain(),<br>thin = samples.get.thin()</font><font face="Arial" color="#000100" size="3"><em>)</em></font><font face="Arial" color="#000100" size="3"> plots a smoothed kernel density estimate for the variable if it is continuous or a histogram if it is discrete.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.autoC:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.autoC(</em></font><font face="Arial" color="#000100" size="3">node, beg = samples.get.beg(), end = samples.get.end(), firstChain = samples.get.firstChain(), lastChain = samples.get.lastChain(),<br>thin = samples.get.thin()</font><font face="Arial" color="#000100" size="3"><em>)</em></font><font face="Arial" color="#000100" size="3"> plots the autocorrelation function of the variable. <br><br></font><font face="Arial" color="#000100" size="3"><strong><em>sampless.stats:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.stats(</em></font><font face="Arial" color="#000100" size="3">node, beg = samples.get.beg(), end = samples.get.end(), firstChain = samples.get.firstChain(), lastChain = samples.get.lastChain(),<br>thin = samples.get.thin()</font><font face="Arial" color="#000100" size="3"><em>)</em></font><font face="Arial" color="#000100" size="3"> produces summary statistics for the variable, pooling over the chains selected. The required percentiles can be selected using the </font><font face="Arial" color="#000100" size="3"><em>percentile</em></font><font face="Arial" color="#000100" size="3"> selection box. The quantity reported in the MC error column gives an estimate of s / N</font><font face="Arial" color="#000100" size="3"><sup>1/2</sup></font><font face="Arial" color="#000100" size="3">, the Monte Carlo standard error of the mean. The batch means method outlined by Roberts (1996; p.50) is used to estimate s.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.bgr:</em></strong></font><font face="Arial" color="#000100" size="3"><strong> </strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.bgr(</em></font><font face="Arial" color="#000100" size="3">node, beg = samples.get.beg(), end = samples.get.end(), firstChain = samples.get.firstChain(), lastChain = samples.get.lastChain(),<br>thin = samples.get.thin()</font><font face="Arial" color="#000100" size="3"><em>)</em></font><font face="Arial" color="#000100" size="3"> calculates the Gelman-Rubin convergence statistic, as modified by Brooks and Gelman (1998). The width of the central 80% interval of the pooled runs is green, the average width of the 80% intervals within the individual runs is blue, and their ratio </font><font face="Arial" color="#000100" size="3"><em>R</em></font><font face="Arial" color="#000100" size="3"> (= pooled / within) is red - for plotting purposes the pooled and within interval widths are normalised to have an overall maximum of one. The statistics are calculated in bins of length 50: </font><font face="Arial" color="#000100" size="3"><em>R</em></font><font face="Arial" color="#000100" size="3"> would generally be expected to be greater than 1 if the starting values are suitably over-dispersed. Brooks and Gelman (1998) emphasise that one should be concerned both with convergence of </font><font face="Arial" color="#000100" size="3"><em>R</em></font><font face="Arial" color="#000100" size="3"> to 1, and with convergence of both the pooled and within interval widths to stability.<br><br>The following low level functions can be used to perform calculations on stored samples.<br></font><font face="Arial" color="#000000" size="3"><em><br></em></font><font face="Arial" color="#000100" size="3"><strong><em>samples.set.beg</em></strong></font><font face="Arial" color="#000100" size="3"> :The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.beg(beg)</em></font><font face="Arial" color="#000100" size="3"> is used to set the first iteration of the stored sample used for calculating statistics to </font><font face="Arial" color="#000100" size="3"><em>beg</em></font><font face="Arial" color="#000100" size="3">.</font><font face="Arial" color="#000100" size="3"><strong><em><br><br>samples.set.end:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.end(end)</em></font><font face="Arial" color="#000100" size="3"> is used to set the last iteration of the stored sample used for calculating statistics to </font><font face="Arial" color="#000100" size="3"><em>end.</em></font><font face="Arial" color="#000100" size="3"><br><br></font><font face="Arial" color="#000000" size="3"><strong><em>samples.set.thin: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.thin(thin)</em></font><font face="Arial" color="#000100" size="3"> is used to set </font><font face="Arial" color="#000000" size="3">numerical field used to select every </font><font face="Arial" color="#000000" size="3"><em>k</em></font><font face="Arial" color="#000000" size="3"><sup>th</sup></font><font face="Arial" color="#000000" size="3"> iteration of each chain to contribute to the statistics being calculated, where </font><font face="Arial" color="#000000" size="3"><em>k</em></font><font face="Arial" color="#000000" size="3"> is the value of the field. Note the difference between this and the thinning facility of the update function: when thinning via the update function we are </font><font face="Arial" color="#000000" size="3"><em>permanently</em></font><font face="Arial" color="#000000" size="3"> discarding samples as the MCMC simulation runs, whereas here we have already generated (and stored) a suitable number of (posterior) samples and may wish to discard some of them only temporarily. Thus, setting </font><font face="Arial" color="#000000" size="3"><em>k</em></font><font face="Arial" color="#000000" size="3"> &gt; 1 here will not have any impact on the storage (memory) requirements; if you wish to reduce the number of samples actually stored (to free-up memory) you should thin via the update function.<br></font><font face="Arial" color="#000100" size="3"><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.set.firstChain: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.firstChain(firstChain)</em></font><font face="Arial" color="#000100" size="3"> is used to set the first chain of the stored sample used for calculating statistics to be </font><font face="Arial" color="#000100" size="3"><em>firstChain</em></font><font face="Arial" color="#000100" size="3">.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.set.lastChain: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.lastChain(lastChain)</em></font><font face="Arial" color="#000100" size="3"> is used to set the last chain of the stored sample used for calculating statistics to be </font><font face="Arial" color="#000100" size="3"><em>lastChain</em></font><font face="Arial" color="#000100" size="3">.<br></font><font face="Arial" color="#000000" size="3"><em><br></em></font><font face="Arial" color="#000100" size="3"><strong><em>samples.get.beg</em></strong></font><font face="Arial" color="#000100" size="3"> :The function </font><font face="Arial" color="#000100" size="3"><em>samples.get.beg()</em></font><font face="Arial" color="#000100" size="3"> returns the first iteration of the stored sample used for calculating statistics.</font><font face="Arial" color="#000100" size="3"><strong><em><br><br>samples.get.end:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>samples.get.end()</em></font><font face="Arial" color="#000100" size="3"> returns the last iteration of the stored sample used for calculating statistics to </font><font face="Arial" color="#000100" size="3"><em>end.</em></font><font face="Arial" color="#000100" size="3"><br><br></font><font face="Arial" color="#000000" size="3"><strong><em>samples.get.thin: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.set.thin(thin) </em></font><font face="Arial" color="#000000" size="3">returns the thin parameter.<br></font><font face="Arial" color="#000100" size="3"><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.get.firstChain: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.get.firstChain()</em></font><font face="Arial" color="#000100" size="3"> returns the first chain of the stored sample used for calculating statistics.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.get.lastChain: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>samples.get.lastChain()</em></font><font face="Arial" color="#000100" size="3"> returns the last chain of the stored sample used for calculating statistics to be </font><font face="Arial" color="#000100" size="3"><em>lastChain</em></font><font face="Arial" color="#000100" size="3">.<br><br>The next three functions have the implicit arguments beg&nbsp;= &nbsp;samples.get.beg(), end&nbsp;=&nbsp;samples.get.end(), thin&nbsp;= &nbsp;samples.get.thin(), firstChain&nbsp;= samples.get.firstChain(), lastChain&nbsp;= &nbsp;samples.get.lastChain(). They can be used to retrieve stored samples for a a set of nodes.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.size:</em></strong></font><font face="Arial" color="#000100" size="3"> The </font><font face="Arial" color="#000100" size="3"><em>samples.size(node)</em></font><font face="Arial" color="#000100" size="3"> function returns the size of the stored sample for the scalar quantity node.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>samples.sample:</em></strong></font><font face="Arial" color="#000100" size="3"> The </font><font face="Arial" color="#000100" size="3"><em>samples.samples(node)</em></font><font face="Arial" color="#000100" size="3"> function returns an array of stored values for the scalar quanity node.<br><br></font><font face="Arial" color="#000100" size="3"><strong>samples.monitors:</strong></font><font face="Arial" color="#000100" size="3"> The </font><font face="Arial" color="#000100" size="3"><em>samples.monitors(node)</em></font><font face="Arial" color="#000100" size="3"> function returns a list of scalar names as strings that have a monitor set for them and with the monitors having some stored values between beg and end. </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> can be a vector quantity with sub ranges given to indices and </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> can be '*'.<br><br></font><font face="Arial" color="#000100" size="2"><a id="Summary"></font><font face="Arial" color="#000100" size="5"><strong>Summary...</strong></font><font face="Arial" color="#000100" size="2"></a> </font><font face="Arial" color="#0000FF" size="3"><a href="#Contents">[top]</a></font><font face="Arial" color="#000100" size="2"><br></font><font face="Arial" color="#000100" size="3"><strong><br></strong></font><font face="Arial" color="#000100" size="3">The functions </font><font face="Arial" color="#000100" size="3"><em>summary.set, summary.stats, summary.clear</em></font><font face="Arial" color="#000100" size="3">, are used to </font><font face="Arial" color="#000000" size="3">calculate running means, standard deviations and quantiles. The</font><font face="Arial" color="#000100" size="3"> functions are less powerful and general than the </font><font face="Arial" color="#000100" size="3"><em>samples </em></font><font face="Arial" color="#000100" size="3">functions, but they also require much less storage (an important consideration when many variables and/or long runs are of interest). They take a single argument </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> which can either be a name of a quantity in the model as a string or an R object with the same name as a quantity in the model.<br></font><font face="Arial" color="#000100" size="3"><em><br></em></font><font face="Arial" color="#000100" size="3"><strong><em>summary.set:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>summary.set(node)</em></font><font face="Arial" color="#000100" size="3"> creates a monitor that starts recording the running totals for </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3">.<br><br></font><font face="Arial" color="#000000" size="3"><strong><em>summary.stats:</em></strong></font><font face="Arial" color="#000000" size="3"><strong> </strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>summary.stats(node)</em></font><font face="Arial" color="#000100" size="3"> </font><font face="Arial" color="#000000" size="3">displays the running means, standard deviations, and 2.5%, 50% (median) and 97.5% quantiles for </font><font face="Arial" color="#000000" size="3"><em>node</em></font><font face="Arial" color="#000000" size="3">. </font><font face="Arial" color="#000000" size="3"><strong>Note that these running quantiles are calculated via an approximate algorithm (see</strong></font><font face="Arial" color="#000000" size="3"> </font><font face="Arial" color="#0000FF" size="3"><a href="../Manuals/References.html#RunningQuantilesReference"></font><font face="Arial" color="#0000FF" size="3"><u>here</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3"> </font><font face="Arial" color="#000000" size="3"><strong>for details) and should therefore be used with caution.</strong></font><font face="Arial" color="#000000" size="3"><br></font><font face="Arial" color="#000100" size="3"><br></font><font face="Arial" color="#000100" size="3"><strong><em>summary.clear: </em></strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>summary.clear(node)</em></font><font face="Arial" color="#000100" size="3"> removes the monitor calculating running totals for </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3">.<br><br></font><font face="Arial" color="#000100" size="2"><a id="Rank"></font><font face="Arial" color="#000100" size="5"><strong>Rank...</strong></font><font face="Arial" color="#000100" size="2"></a> </font><font face="Arial" color="#0000FF" size="3"><a href="#Contents">[top]</a></font><font face="Arial" color="#000100" size="3"><br></font><font face="Arial" color="#000100" size="3"><strong><br></strong></font><font face="Arial" color="#000100" size="3">The functions </font><font face="Arial" color="#000100" size="3"><em>rank.set, rank.stats, rank.clear</em></font><font face="Arial" color="#000100" size="3">, are used to </font><font face="Arial" color="#000000" size="3">calculate ranks of vector valued quantities in the model. </font><font face="Arial" color="#000100" size="3">They take a single argument </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> which can either be a name of a quantity in the model as a string or an R object with the same name as a quantity in the model.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>rank.set:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>rank.set(node)</em></font><font face="Arial" color="#000100" size="3"> creates a monitor that starts building running histograms to represent the rank of each component of </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3">. An amount of storage proportional to the square of the number of components of </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> is allocated. Even when </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3"> has thousands of components this can require less storage than calculating the ranks explicitly in the model specification and storing their samples, and it is also much quicker.<br><br></font><font face="Arial" color="#000100" size="3"><strong><em>rank.stats:</em></strong></font><font face="Arial" color="#000100" size="3"><strong> </strong></font><font face="Arial" color="#000100" size="3">The function </font><font face="Arial" color="#000100" size="3"><em>rank.stats(node)</em></font><font face="Arial" color="#000100" size="3"> </font><font face="Arial" color="#000000" size="3">displays </font><font face="Arial" color="#000100" size="3">summarises of the distribution of the ranks of each component of the variable </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3">. <br><br></font><font face="Arial" color="#000100" size="3"><strong><em>rank.clear:</em></strong></font><font face="Arial" color="#000100" size="3"> The function </font><font face="Arial" color="#000100" size="3"><em>rank.clear(node)</em></font><font face="Arial" color="#000100" size="3"> removes the monitor calculating running running histograms for </font><font face="Arial" color="#000100" size="3"><em>node</em></font><font face="Arial" color="#000100" size="3">.<br><br></font><font face="Arial" color="#000100" size="2"><a id="DIC"></font><font face="Arial" color="#000100" size="5"><strong>DIC...</strong></font><font face="Arial" color="#000100" size="2"></a> </font><font face="Arial" color="#0000FF" size="3"><a href="#Contents">[top]</a></font><font face="Arial" color="#000100" size="2"><br></font><font face="Arial" color="#FF00FF" size="3"><br></font><font face="Arial" color="#000000" size="3">The </font><font face="Arial" color="#000000" size="3"><em>DIC </em></font><font face="Arial" color="#000000" size="3">functions are used to evaluate the </font><font face="Arial" color="#000000" size="3"><em>Deviance Information Criterion</em></font><font face="Arial" color="#000000" size="3"> (DIC; </font><font face="Arial" color="#0000FF" size="3"><a href="../Docu/References.html#DICPaper"></font><font face="Arial" color="#0000FF" size="3"><u>Spiegelhalter&nbsp;</u></font><font face="Arial" color="#0000FF" size="3"><em><u>et&nbsp;al</u></em></font><font face="Arial" color="#0000FF" size="3"><u>.,&nbsp;2002</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3">) and related statistics </font><font face="Arial" color="#000100" size="3">-</font><font face="Arial" color="#000000" size="3"> these can be used to assess model complexity and compare different models. Most of the </font><font face="Arial" color="#0000FF" size="3"><a href="../Examples/Volumeii.html"></font><font face="Arial" color="#0000FF" size="3"><u>examples</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3"> packaged with </font><font face="Arial" color="#000000" size="3"><em>WinBUGS</em></font><font face="Arial" color="#000000" size="3"> contain an example of their usage.<br><br></font><font face="Arial" color="#000000" size="3"><strong>It is important to note that DIC assumes the posterior mean to be a good estimate of the stochastic parameters. If this is not so, say because of extreme skewness or even bimodality, then DIC may not be appropriate. There are also circumstances, such as with mixture models, in which WinBUGS will not permit the calculation of DIC and so the menu option is greyed out. Please see the WinBUGS 1.4 web-page for current restrictions:<br></strong></font><font face="Arial" color="#FF0000" size="3"><strong><br></strong></font><font face="Arial" color="#FF0000" size="3">&nbsp;&nbsp;&nbsp;</font><font face="Arial" color="#000000" size="3">http://www.mrc-bsu.cam.ac.uk/bugs/winbugs/contents.shtml<br></font><font face="Arial" color="#000000" size="3"><strong><em><br>dic.set:</em></strong></font><font face="Arial" color="#000000" size="3"> The function </font><font face="Arial" color="#000000" size="3"><em>dic.set()</em></font><font face="Arial" color="#000000" size="3"> creates monitors that start calculating DIC and related statistics - the user should ensure that convergence has been achieved before pressing </font><font face="Arial" color="#000000" size="3"><em>set</em></font><font face="Arial" color="#000000" size="3"> as all subsequent iterations will be used in the calculation.<br><br></font><font face="Arial" color="#000000" size="3"><strong><em>dic.clear:</em></strong></font><font face="Arial" color="#000000" size="3"> The function </font><font face="Arial" color="#000000" size="3"><em>dic.set()</em></font><font face="Arial" color="#000000" size="3"> deletes monitors that have ben created calculating DIC and related statistics<br><br></font><font face="Arial" color="#000000" size="3"><strong><em>dic.stats:</em></strong></font><font face="Arial" color="#000000" size="3"> The function </font><font face="Arial" color="#000000" size="3"><em>dic.stats()</em></font><font face="Arial" color="#000000" size="3"> displays the calculated statistics, as described below; please see </font><font face="Arial" color="#0000FF" size="3"><a href="../Docu/References.html#DICPaper"></font><font face="Arial" color="#0000FF" size="3"><u>Spiegelhalter&nbsp;</u></font><font face="Arial" color="#0000FF" size="3"><em><u>et&nbsp;al</u></em></font><font face="Arial" color="#0000FF" size="3"><u>.&nbsp;(2002)</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3"> for full details; the section </font><font face="Arial" color="#0000FF" size="3"><a href="../Docu/Tricks.html"></font><font face="Arial" color="#0000FF" size="3"><u>Tricks:&nbsp;Advanced&nbsp;Use&nbsp;of&nbsp;the&nbsp;BUGS&nbsp;Language</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3"> also contains some comments on the use of DIC.<br><br></font><font face="Arial" color="#000000" size="3"><strong>Dbar:</strong></font><font face="Arial" color="#000000" size="3"> this is the posterior mean of the deviance, which is exactly the same as if the node 'deviance' had been monitored (see </font><font face="Arial" color="#0000FF" size="3"><a href="#DevianceDefinition"></font><font face="Arial" color="#0000FF" size="3"><u>here</u></font><font face="Arial" color="#0000FF" size="3"></a></font><font face="Arial" color="#000000" size="3">). This deviance is defined as -2 * log(likelihood): 'likelihood' is defined as p( </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> | </font><font face="Arial" color="#000000" size="3"><em>theta</em></font><font face="Arial" color="#000000" size="3"> ), where </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> comprises all stochastic nodes given values (i.e. data), and </font><font face="Arial" color="#000000" size="3"><em>theta</em></font><font face="Arial" color="#000000" size="3"> comprises the </font><font face="Arial" color="#000000" size="3"><em>stochastic parents</em></font><font face="Arial" color="#000000" size="3"> of </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> - 'stochastic parents' are the stochastic nodes upon which the distribution of </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> depends, when collapsing over all logical relationships.<br><br></font><font face="Arial" color="#000000" size="3"><strong>Dhat:</strong></font><font face="Arial" color="#000000" size="3"> this is a point estimate of the deviance (-2 * log(likelihood)) obtained by substituting in the posterior means </font><font face="Arial" color="#000000" size="3"><em>theta.bar</em></font><font face="Arial" color="#000000" size="3"> of </font><font face="Arial" color="#000000" size="3"><em>theta</em></font><font face="Arial" color="#000000" size="3">: thus Dhat = -2 * log(p( </font><font face="Arial" color="#000000" size="3"><em>y</em></font><font face="Arial" color="#000000" size="3"> | </font><font face="Arial" color="#000000" size="3"><em>theta.bar</em></font><font face="Arial" color="#000000" size="3"> )).</font><font face="Arial" color="#000000" size="3"><em><br></em></font><font face="Arial" color="#000000" size="3"><br></font><font face="Arial" color="#000000" size="3"><strong>pD:</strong></font><font face="Arial" color="#000000" size="3"> this is 'the effective number of parameters', and is given by </font><font face="Arial" color="#000000" size="3"><strong>pD = Dbar - Dhat</strong></font><font face="Arial" color="#000000" size="3">. Thus pD is the posterior mean of the deviance minus the deviance of the posterior means.<br><br></font><font face="Arial" color="#000000" size="3"><strong>DIC:</strong></font><font face="Arial" color="#000000" size="3"> this is the 'Deviance Information Criterion', and is given by </font><font face="Arial" color="#000000" size="3"><strong>DIC&nbsp;=&nbsp;Dbar&nbsp;+&nbsp;pD&nbsp;=&nbsp;Dhat&nbsp;+&nbsp;2&nbsp;*&nbsp;pD</strong></font><font face="Arial" color="#000000" size="3">. The model with the smallest DIC is estimated to be the model that would best predict a replicate dataset of the same structure as that currently observed.</font><font face="Arial" color="#000000" size="3"><strong><br></strong></font><font face="Arial" color="#000000" size="3"><br></font></p></body></html>